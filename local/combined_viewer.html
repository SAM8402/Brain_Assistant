<!doctype html>
<html lang="en" style="height:100%;">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v5.3.0/css/ol.css" type="text/css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
        }

        /* Main container with flexible layout */
        .main-container {
            display: flex;
            flex-direction: row;
            height: 100vh;
            width: 100vw;
            background: #0f0f0f;
            overflow: hidden;
            position: relative;
        }

        /* Viewers column - takes full width when chatbot is closed */
        .viewers-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: #0f0f0f;
        }

        /* Chatbot column - positioned absolutely, no space reserved when closed */
        .chatbot-column {
            position: absolute;
            top: 0;
            right: 0;
            width: 400px;
            height: 100%;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform: translateX(100%);
            overflow: hidden;
            z-index: 1000;
        }

        /* When chatbot is active, shrink the viewers and show chatbot */
        .main-container.chatbot-active .viewers-column {
            width: calc(100% - 400px);
        }

        .chatbot-column.active {
            transform: translateX(0);
        }

        .chatbot-column.active .chatbot-container {
            opacity: 1;
            transform: translateY(0);
        }
        
        @media (max-width: 768px) {
            .main-container {
                margin: 4px;
                border-radius: 8px;
                height: calc(100vh - 8px);
                width: calc(100vw - 8px);
            }
            
            .chatbot-column {
                width: 100vw;
                position: absolute;
                top: 0;
                right: 0;
                height: 100vh;
                z-index: 2000;
                background: rgba(15, 15, 15, 0.98);
                box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
                transform: translateX(100%);
            }
            
            .chatbot-column.active {
                transform: translateX(0);
            }
            
            /* On mobile, don't shrink viewers - use overlay */
            .main-container.chatbot-active .viewers-column {
                width: 100%;
            }
            
            .chatbot-toggle {
                right: 15px;
                width: 45px;
                height: 45px;
            }
            
            .chatbot-toggle svg {
                width: 24px;
                height: 24px;
            }
        }
        
        @media (min-width: 769px) and (max-width: 1200px) {
            .chatbot-column {
                width: 350px;
            }
        }
        
        @media (min-width: 1201px) {
            .chatbot-column {
                width: 450px;
            }
            
            .main-container.chatbot-active .viewers-column {
                width: calc(100% - 450px);
            }
        }
        
        @media (min-width: 769px) and (max-width: 1200px) {
            .chatbot-column {
                width: 350px;
            }
            
            .main-container.chatbot-active .viewers-column {
                width: calc(100% - 350px);
            }
        }

        /* Top row for atlas viewer */
        .atlas-panel {
            height: 50%;
            width: 100%;
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: #0f0f0f;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* Bottom row for thumbnail viewer */
        .thumbnail-panel {
            height: 50%;
            width: 100%;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* Resize handle between panels */
        .resize-handle {
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            cursor: row-resize;
            position: relative;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .resize-handle:hover {
            height: 4px;
            background: rgba(99, 102, 241, 0.5);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        /* Common header style */
        .header {
            margin: 0;
            padding: 20px 24px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .header p {
            margin: 0;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header p::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #6366f1;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        .atlas-panel .header p::before {
            background: #10b981;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }

        /* Atlas viewer specific styles */
        .name-container {
            display: flex;
            width: 100%;
            height: 0;
            position: absolute;
            top: 60px;
            z-index: 10;
        }

        .feature-name {
            font-size: 16px;
            font-weight: 500;
            padding: 12px 24px;
            z-index: 3;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            margin-left: 24px;
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }

        .map {
            height: calc(100% - 60px);
            width: 100%;
            position: relative;
            top: 60px;
            background: #0a0a0a;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* Control panel container */
        .control-panel {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
        }
        
        /* Hide all OpenLayers controls */
        .ol-zoom,
        .ol-rotate,
        .ol-attribution {
            display: none !important;
        }
        
        @media (max-width: 768px) {
            .control-panel {
                left: 8px;
                gap: 8px;
            }
            
            .slider-container {
                width: 20px;
                height: 120px;
            }
            
            .eye-toggle-container {
                width: 20px;
                height: 20px;
            }
        }

        /* Opacity slider styles */
        .slider-container {
            height: 140px;
            width: 24px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .slider-container:hover {
            background: rgba(40, 40, 40, 0.95);
            transform: translateX(-2px);
            border-color: rgba(99, 102, 241, 0.3);
        }

        #opacity-slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;
            width: 3px;
            height: 90px;
            padding: 0;
            margin: 0;
        }

        /* Slider thumb styles */
        #opacity-slider::-webkit-slider-thumb {
            transform: scale(0.6);
            cursor: pointer;
        }

        #opacity-slider::-moz-range-thumb {
            transform: scale(0.6);
            cursor: pointer;
        }

        #opacity-slider::-ms-thumb {
            transform: scale(0.6);
            cursor: pointer;
        }

        .opacity-value {
            font-size: 10px;
            font-weight: 500;
            margin-top: 6px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(99, 102, 241, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Eye toggle button styles */
        .eye-toggle-container {
            width: 24px;
            height: 24px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .eye-toggle-container:hover {
            background: rgba(40, 40, 40, 0.95);
            transform: translateX(-2px) scale(1.05);
            border-color: rgba(99, 102, 241, 0.3);
        }

        .eye-toggle-container:active {
            transform: translateX(-2px) scale(0.95);
        }

        .eye-icon {
            width: 14px;
            height: 14px;
            transition: all 0.3s ease;
            color: rgba(255, 255, 255, 0.8);
        }

        .eye-icon.hidden {
            opacity: 0.3;
            color: rgba(255, 255, 255, 0.5);
        }

        /* Thumbnail viewer specific styles */
        .thumbnail-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: auto;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 10px;
            position: relative;
            flex: 1;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .image-grid-container {
            width: 100%;
            height: 100%;
            border: none;
            overflow: auto;
            position: relative;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .image-grid {
            display: grid;
            gap: 5px;
            width: 100%;
            height: 100%;
            padding: 10px;
            box-sizing: border-box;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .image-grid-wrapper {
            display: flex;
            width: 200%;
            transition: transform 0.5s ease-in-out, width 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .image-container {
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(20, 20, 20, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            width: 85px;
            height: 85px;
            border-radius: 8px;
            overflow: hidden;
        }

        .green-dot {
            width: 8px;
            height: 8px;
            background: #10b981;
            border-radius: 50%;
            position: absolute;
            top: 4px;
            right: 4px;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.8);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { 
                transform: scale(1);
                box-shadow: 0 0 10px rgba(16, 185, 129, 0.8);
            }
            50% { 
                transform: scale(1.2);
                box-shadow: 0 0 20px rgba(16, 185, 129, 1);
            }
            100% { 
                transform: scale(1);
                box-shadow: 0 0 10px rgba(16, 185, 129, 0.8);
            }
        }
        
        /* Theme toggle button */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 2000;
            opacity: 1;
            visibility: visible;
        }
        
        /* Hide theme toggle when chatbot is active */
        .main-container.chatbot-active .theme-toggle {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .theme-toggle:hover {
            transform: scale(1.05);
            background: rgba(40, 40, 40, 0.95);
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .theme-toggle svg {
            width: 24px;
            height: 24px;
            transition: all 0.3s ease;
        }
        
        .theme-toggle .sun-icon {
            color: #fbbf24;
            display: none;
        }
        
        .theme-toggle .moon-icon {
            color: #6366f1;
            display: block;
        }
        
        /* Light theme styles */
        body.light-theme {
            background: #f8f9fa;
        }
        
        body.light-theme .main-container {
            background: #ffffff;
        }
        
        body.light-theme .viewers-column {
            background: #ffffff;
        }
        
        body.light-theme .atlas-panel {
            background: #ffffff;
            border-bottom: 1px solid #e5e7eb;
        }
        
        body.light-theme .thumbnail-panel {
            background: #f8f9fa;
        }
        
        body.light-theme .resize-handle {
            background: #e5e7eb;
        }
        
        body.light-theme .resize-handle:hover {
            background: #3b82f6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        
        body.light-theme .header {
            background: #ffffff;
            color: #1f2937;
            border-bottom: 1px solid #e5e7eb;
        }
        
        body.light-theme .header p::before {
            background: #3b82f6;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        
        body.light-theme .atlas-panel .header p::before {
            background: #10b981;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }
        
        body.light-theme .map {
            background: #f3f4f6;
        }
        
        body.light-theme .feature-name {
            background: rgba(255, 255, 255, 0.95);
            color: #1f2937;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        body.light-theme .slider-container,
        body.light-theme .eye-toggle-container {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        body.light-theme .slider-container:hover,
        body.light-theme .eye-toggle-container:hover {
            background: #ffffff;
            border-color: #3b82f6;
        }
        
        body.light-theme .opacity-value {
            color: #2563eb;
            background: rgba(37, 99, 235, 0.1);
        }
        
        body.light-theme .eye-icon {
            color: #2563eb;
        }
        
        body.light-theme .eye-icon.hidden {
            color: #ef4444;
            opacity: 0.5;
        }
        
        body.light-theme .image-container {
            background: #ffffff;
            border: 2px solid #e5e7eb;
        }
        
        body.light-theme .image-container:hover {
            border-color: #3b82f6;
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.2);
        }
        
        body.light-theme .image-id {
            background: #1f2937;
            color: white;
        }
        
        body.light-theme .selected {
            border: 2px solid #3b82f6 !important;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3) !important;
            background: rgba(59, 130, 246, 0.05) !important;
        }
        
        body.light-theme .series-selector select {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            color: #374151;
        }
        
        body.light-theme .series-selector select:hover {
            border-color: #3b82f6;
            background: #f9fafb;
        }
        
        body.light-theme .chatbot-column {
            background: rgba(255, 255, 255, 0.98);
            border-left: 1px solid #e5e7eb;
        }
        
        body.light-theme .chatbot-header {
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }
        
        body.light-theme .chatbot-header h3 {
            color: #1f2937;
        }
        
        body.light-theme .chatbot-close {
            color: #6b7280;
        }
        
        body.light-theme .chatbot-close:hover {
            background: rgba(0, 0, 0, 0.05);
            color: #1f2937;
        }
        
        body.light-theme .chatbot-messages {
            background: #ffffff;
        }
        
        body.light-theme .user-message p {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        }
        
        body.light-theme .bot-message p {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        
        body.light-theme .bot-message p strong {
            color: #1f2937;
        }
        
        body.light-theme .bot-message p em {
            color: #6b7280;
        }
        
        body.light-theme .bot-message h1,
        body.light-theme .bot-message h2,
        body.light-theme .bot-message h3 {
            color: #1f2937;
        }
        
        body.light-theme .bot-message h3 {
            border-bottom: 1px solid #e5e7eb;
        }
        
        body.light-theme .chatbot-input-container {
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
        }
        
        body.light-theme .mode-selector label {
            color: #6b7280;
        }
        
        body.light-theme .mode-selector label:hover {
            color: #1f2937;
        }
        
        body.light-theme .chat-input input {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            color: #1f2937;
        }
        
        body.light-theme .chat-input input::placeholder {
            color: #9ca3af;
        }
        
        body.light-theme .chat-input input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        body.light-theme .chat-input button {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        }
        
        body.light-theme .chatbot-toggle {
            background: #3b82f6;
            border: 1px solid #2563eb;
        }
        
        body.light-theme .chatbot-toggle:hover {
            background: #2563eb;
            box-shadow: 0 12px 40px rgba(37, 99, 235, 0.4);
        }
        
        body.light-theme .loading {
            border: 2px solid #e5e7eb;
            border-top: 2px solid #3b82f6;
        }
        
        body.light-theme .history-btn,
        body.light-theme .clear-btn {
            background: rgba(0, 0, 0, 0.05);
            color: #374151;
        }
        
        body.light-theme .history-btn:hover,
        body.light-theme .clear-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #1f2937;
        }
        
        body.light-theme .current-region {
            color: #2563eb;
        }
        
        body.light-theme .theme-toggle {
            background: #ffffff;
            border: 1px solid #e5e7eb;
        }
        
        body.light-theme .theme-toggle:hover {
            background: #f9fafb;
            border-color: #3b82f6;
        }
        
        body.light-theme .theme-toggle .sun-icon {
            display: block;
        }
        
        body.light-theme .theme-toggle .moon-icon {
            display: none;
        }
        
        /* Smooth transitions for theme switching */
        body, .main-container, .viewers-column, .atlas-panel, .thumbnail-panel,
        .header, .map, .feature-name, .slider-container, .eye-toggle-container,
        .image-container, .series-selector select, .chatbot-column,
        .chatbot-header, .chatbot-messages, .bot-message p, .chatbot-input-container,
        .chat-input input, .chat-input button, .chatbot-toggle, .theme-toggle {
            transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        .image-container:hover {
            transform: translateY(-2px) scale(1.02);
            background: rgba(30, 30, 30, 0.9);
            border-color: rgba(99, 102, 241, 0.5);
            box-shadow: 0 8px 24px rgba(99, 102, 241, 0.2);
        }

        .image-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .image-id {
            position: absolute;
            bottom: 4px;
            left: 4px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.7);
            font-size: 9px;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
        }


        .selected {
            border: 1px solid #6366f1 !important;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.4), inset 0 0 10px rgba(99, 102, 241, 0.2) !important;
            transform: scale(1.05) !important;
            background: rgba(99, 102, 241, 0.1) !important;
        }

        /* Series selector */
        .series-selector {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 16px;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .series-selector select {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(30, 30, 30, 0.8);
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .series-selector select:hover {
            border-color: rgba(99, 102, 241, 0.5);
            background: rgba(40, 40, 40, 0.9);
        }

        .series-selector select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }

        /* Chatbot styles */
        .chatbot-container {
            height: 100%;
            background: transparent;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            opacity: 1;
            transform: translateY(0);
        }

        .chatbot-header {
            padding: 24px;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(20px);
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chatbot-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .chatbot-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .chatbot-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }

        .chatbot-messages {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            background: transparent;
        }
        
        /* Custom scrollbar for messages */
        .chatbot-messages::-webkit-scrollbar {
            width: 6px;
        }
        
        .chatbot-messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .chatbot-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .chatbot-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .message {
            margin-bottom: 15px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user-message {
            text-align: right;
        }

        .user-message p {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            padding: 12px 16px;
            border-radius: 16px 16px 4px 16px;
            display: inline-block;
            max-width: 80%;
            margin: 0;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }

        .bot-message {
            text-align: left;
        }

        .bot-message p {
            background: rgba(30, 30, 30, 0.8);
            color: rgba(255, 255, 255, 0.9);
            padding: 12px 16px;
            border-radius: 16px 16px 16px 4px;
            display: inline-block;
            max-width: 80%;
            margin: 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            line-height: 1.6;
        }
        
        /* Formatting styles for bot messages */
        .bot-message p strong {
            font-weight: 600;
            color: #fff;
        }
        
        .bot-message p em {
            font-style: italic;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .bot-message p u {
            text-decoration: underline;
            text-underline-offset: 2px;
        }
        
        /* Better spacing for formatted content */
        .bot-message p br + br {
            line-height: 0.5;
        }
        
        /* Styles for markdown headers */
        .bot-message h1 {
            font-size: 1.4em;
            font-weight: 600;
            margin: 0.8em 0 0.4em 0;
            color: #fff;
        }
        
        .bot-message h2 {
            font-size: 1.2em;
            font-weight: 500;
            margin: 0.7em 0 0.3em 0;
            color: rgba(255, 255, 255, 0.95);
        }
        
        .bot-message h3 {
            font-size: 1.1em;
            font-weight: 500;
            margin: 0.6em 0 0.3em 0;
            color: rgba(255, 255, 255, 0.9);
            padding-bottom: 0.2em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .bot-message h1:first-child,
        .bot-message h2:first-child,
        .bot-message h3:first-child {
            margin-top: 0;
        }

        .chatbot-input-container {
            padding: 20px;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mode-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .mode-selector label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.6);
            transition: color 0.2s;
        }
        
        .mode-selector label:hover {
            color: rgba(255, 255, 255, 0.9);
        }

        .mode-selector input[type="radio"] {
            cursor: pointer;
            accent-color: #6366f1;
        }

        .chat-input {
            display: flex;
            gap: 10px;
        }

        .chat-input input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 14px;
            background: rgba(30, 30, 30, 0.8);
            color: rgba(255, 255, 255, 0.9);
            transition: all 0.2s ease;
        }
        
        .chat-input input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .chat-input input:focus {
            outline: none;
            border-color: rgba(99, 102, 241, 0.5);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
            background: rgba(40, 40, 40, 0.9);
        }

        .chat-input button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 13px;
        }

        .chat-input button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        }

        .chat-input button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .chatbot-toggle {
            position: fixed;
            top: 50%;
            right: 20px;
            width: 48px;
            height: 48px;
            background: rgba(99, 102, 241, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.4);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1999;
            transform: translateY(-50%);
        }

        .chatbot-toggle:hover {
            transform: translateY(-50%) scale(1.05);
            box-shadow: 0 12px 40px rgba(99, 102, 241, 0.6);
            background: #6366f1;
        }

        .chatbot-toggle.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-50%) translateX(20px);
        }

        .chatbot-toggle svg {
            transition: transform 0.3s ease;
        }

        .chatbot-toggle:hover svg {
            transform: scale(1.1);
        }

        .chatbot-toggle svg {
            width: 26px;
            height: 26px;
            color: white;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* History controls */
        .history-controls {
            position: absolute;
            top: 24px;
            right: 60px;
            display: flex;
            gap: 8px;
        }

        .history-btn, .clear-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: rgba(255, 255, 255, 0.8);
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .history-btn:hover, .clear-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }


        .current-region {
            color: #6366f1;
            font-weight: 500;
            margin-left: 10px;
        }

        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 3000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 16px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalAppear 0.3s ease-out;
        }

        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-header {
            background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
        }

        .close-modal {
            font-size: 28px;
            font-weight: 300;
            color: white;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .close-modal:hover {
            transform: scale(1.2);
        }

        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: #f9fafb;
        }

        .history-stats {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            font-size: 14px;
            color: #374151;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .history-region-group {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .history-region-header {
            color: #2563eb;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .history-item {
            padding: 10px;
            border-left: 3px solid #e5e7eb;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        .history-item.user_query {
            border-left-color: #2563eb;
            background: #dbeafe;
        }

        .history-item.region_info {
            border-left-color: #10b981;
            background: #f0fdf4;
        }

        .history-item.assistant_response {
            border-left-color: #3b82f6;
            background: #eff6ff;
        }

        .history-item-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
            color: #6b7280;
        }

        .history-type {
            font-weight: 600;
        }

        .history-timestamp {
            font-style: italic;
        }

        .history-content {
            font-size: 14px;
            color: #374151;
            line-height: 1.5;
        }

        .modal-footer {
            padding: 20px;
            background: white;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .btn-primary, .btn-secondary {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .btn-secondary {
            background: #e5e7eb;
            color: #374151;
        }

        .btn-secondary:hover {
            background: #d1d5db;
        }

        .no-history {
            text-align: center;
            padding: 40px;
            color: #6b7280;
            font-size: 16px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v5.3.0/build/ol.js"></script>
    <title>Combined Brain Viewer</title>
</head>

<body style="height:100%;">
    <div class="main-container">
        <!-- Theme Toggle Button -->
        <button class="theme-toggle" id="themeToggle" title="Toggle theme">
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
        </button>
        <!-- Left column: Viewers -->
        <div class="viewers-column">
            <!-- Top row: Atlas viewer panel -->
            <div class="atlas-panel">
                <div class="header">
                    <p>Atlas Viewer - Biosample: <span id="atlas-biosample">222</span> Section: <span id="atlas-section">1000</span></p>
                </div>
                <div class="name-container">
                    <span class="feature-name" id="feature-name"></span>
                </div>
                <div id="map" class="map"></div>

                <!-- Control panel -->
                <div class="control-panel">
                    <!-- Opacity slider control -->
                    <div class="slider-container">
                        <input type="range" min="0" max="99" value="50" class="slider" id="opacity-slider" orient="vertical">
                        <div class="opacity-value" id="opacity-value">50</div>
                    </div>

                    <!-- Eye toggle button -->
                    <div class="eye-toggle-container" id="eye-toggle" title="Toggle annotations visibility">
                        <svg class="eye-icon" id="eye-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                    </div>
                </div>
            </div>

            <!-- Resize handle -->
            <div class="resize-handle"></div>

            <!-- Bottom row: Thumbnail viewer panel -->
            <div class="thumbnail-panel" id="thumbnail-panel">
                <div class="header">
                    <p>Thumbnail Viewer - Biosample: <span id="thumbnail-biosample">222</span> 
                       <span class="series-selector">
                           Series: <select id="series-select">
                               <option value="NISSL">NISSL</option>
                               <option value="HEOS">H&E</option>
                               <option value="BFI">Block Face Image</option>
                               <option value="MYEL">Myelin</option>
                           </select>
                       </span>
                    </p>
                </div>
                <div class="thumbnail-content">
                    <div class="container">
                        <div class="image-grid-container">
                            <div class="image-grid-wrapper">
                                <div id="image-grid-1" class="image-grid"></div>
                                <div id="image-grid-2" class="image-grid"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right column: Chatbot -->
        <div class="chatbot-column" id="chatbotColumn">
            <!-- Chatbot Container -->
            <div class="chatbot-container" id="chatbotContainer">
                <div class="chatbot-header">
                    <h3>Brain AI Assistant<span id="currentRegion" class="current-region"></span></h3>
                    <div class="history-controls">
                        <button class="history-btn" id="historyBtn" title="View Chat History">üìú</button>
                        <button class="clear-btn" id="clearBtn" title="Clear Chat History">üóëÔ∏è</button>
                    </div>
                    <button class="chatbot-close" id="chatbotClose">&times;</button>
                </div>
                <div class="chatbot-messages" id="chatMessages">
                    <!-- Messages will be added dynamically -->
                </div>
                <div class="chatbot-input-container">
                    <div class="mode-selector">
                        <label>
                            <input type="radio" name="mode" value="fast" checked> Fast
                        </label>
                        <label>
                            <input type="radio" name="mode" value="web"> Detailed (Web)
                        </label>
                        <label>
                            <input type="radio" name="mode" value="ultra"> Ultra-fast
                        </label>
                    </div>
                    <div class="chat-input">
                        <input type="text" id="questionInput" placeholder="Ask a question about the selected brain region...">
                        <button id="askBtn" disabled>Ask</button>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- Chatbot Toggle Button -->
    <button class="chatbot-toggle" id="chatbotToggle">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
        </svg>
    </button>

    <!-- Chat History Modal -->
    <div class="modal" id="historyModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Chat History</h3>
                <span class="close-modal" id="closeHistoryModal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="history-stats">
                    <span id="historyStats">Loading...</span>
                </div>
                <div class="history-list" id="historyList">
                    <!-- History items will be loaded here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="downloadHistory">Download History</button>
                <button class="btn-primary" id="closeHistoryBtn">Close</button>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        // ==================== Configuration ====================
        // These values would be dynamically set by the Flask app
        const THUMBNAIL_API_URL = `https://llm.humanbrain.in:1062/get/brain/thumbnails/100`;
        const GEOJSON_URL = `https://apollo2.humanbrain.in/iipsrv/ddn/storageIIT/humanbrain/analytics/222/appData/atlasEditor/189/NISL/1000/222-NISL-1000-FlatTree::IIT:V1:SS-100:306:1000:1000.json`;
        const IMAGE_URL = `https://apollo2.humanbrain.in/iipsrv/fcgi-bin/iipsrv.fcgi?FIF=/ddn/storageIIT/humanbrain/analytics/222/NISL/B_222_FB74-SL_334-ST_NISL-SE_1000_compressed.jp2&WID=1024&GAM=1.4&MINMAX=1:0,255&MINMAX=2:0,255&MINMAX=3:0,255&JTL={z},{tileIndex}`;
        
        // Initial configuration
        let currentBiosample = 222;
        let currentSection = 1000;
        let currentSeriesType = 'NISSL';
        const session_id = 'demo_session';
        const tool_name = 'combined_viewer';
        
        // ==================== Panel Resize Functionality ====================
        let isResizing = false;
        const resizeHandle = document.querySelector('.resize-handle');
        const atlasPanel = document.querySelector('.atlas-panel');
        const thumbnailPanel = document.querySelector('.thumbnail-panel');
        const mainContainer = document.querySelector('.main-container');
        
        resizeHandle.addEventListener('mousedown', function(e) {
            isResizing = true;
            document.body.style.cursor = 'row-resize';
            document.body.style.userSelect = 'none';
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = mainContainer.getBoundingClientRect();
            const newAtlasHeight = ((e.clientY - containerRect.top) / containerRect.height) * 100;
            
            if (newAtlasHeight >= 20 && newAtlasHeight <= 80) {
                atlasPanel.style.height = newAtlasHeight + '%';
                thumbnailPanel.style.height = (100 - newAtlasHeight) + '%';
                
                if (window.map) {
                    setTimeout(() => window.map.updateSize(), 100);
                }
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        // ==================== Atlas Viewer Code ====================
        const Feature = ol.Feature;
        const Map = ol.Map;
        const View = ol.View;
        const GeoJSON = ol.format.GeoJSON;
        const Circle = ol.geom.Circle;
        const Point = ol.geom.Point;
        const Icon = ol.style.Icon;
        const TileLayer = ol.layer.Tile;
        const VectorLayer = ol.layer.Vector;
        const OSM = ol.source.OSM;
        const VectorSource = ol.source.Vector;
        const CircleStyle = ol.style.Circle;
        const Fill = ol.style.Fill;
        const Stroke = ol.style.Stroke;
        const Style = ol.style.Style;
        const Zoomify = ol.source.Zoomify;
        const Select = ol.interaction.Select;

        // Atlas viewer variables
        let opacityAtlas = '50';
        let vectorSource;
        let selectInteraction;
        let annotationsVisible = true;
        let currentSelectedId = null;
        let vectorLayer;
        let map;
        let notAvailableTimeout = null;

        async function getGeoJSON(url) {
            try {
                const response = await fetch(url);
                return await response.json();
            } catch (error) {
                console.error('Error fetching GeoJSON:', error);
                return null;
            }
        }

        function styleFunction(feature) {
            if (typeof (opacityAtlas) == "number") {
                opacityAtlas = '50'
            }
            var data = feature.get('data')
            var clr = '#FF000070'

            if (data !== undefined && data.color_hex_triplet != undefined) {
                clr = data.color_hex_triplet;
                if (!data.color_hex_triplet.startsWith('#')) {
                    clr = '#' + clr
                }
            }

            if (clr.length == 7) {
                var atlasClr = clr;
                clr = clr + opacityAtlas;
            }

            var st = [
                new Style({
                    zIndex: -1,
                    stroke: new Stroke({
                        color: atlasClr,
                        width: 2.5,
                    }),
                    fill: new Fill({
                        color: clr
                    }),
                }),
            ];

            var geometry = feature.getGeometry();
            if (geometry.getType() === 'LineString') {
                var coordinates = geometry.getCoordinates();
                if (coordinates.length >= 2) {
                    var start = coordinates[coordinates.length - 2];
                    var end = coordinates[coordinates.length - 1];

                    var dx = end[0] - start[0];
                    var dy = end[1] - start[1];
                    var rotation = Math.atan2(dy, dx);

                    st.push(new Style({
                        stroke: new Stroke({
                            color: '#000000',
                            width: 3,
                        })
                    }));

                    st.push(new Style({
                        geometry: new Point(end),
                        image: new Icon({
                            src: 'https://apollo2.humanbrain.in/viewer/assets/images/colorsvg/right_arrow.svg',
                            anchor: [0.75, 0.5],
                            rotateWithView: true,
                            rotation: -rotation,
                        })
                    }));
                }
            }

            st.push(new Style({
                zIndex: -1,
                image: new CircleStyle({
                    radius: 5.9,
                    stroke: new Stroke({
                        color: atlasClr,
                        width: 1,
                    }),
                    fill: new Fill({
                        color: clr,
                    }),
                }),
                geometry: function (feature) {
                    var coordinates = feature.getGeometry().getCoordinates();
                    return new Point(coordinates);
                },
            }));

            return st;
        }

        function updateLayerOpacity() {
            if (vectorSource) {
                vectorSource.getFeatures().forEach(feature => {
                    const data = feature.get('data');
                    const isHighlighted = currentSelectedId !== null && data && data.id === currentSelectedId;
                    
                    if (isHighlighted) {
                        feature.setStyle(new Style({
                            stroke: new Stroke({
                                color: 'red',
                                width: 3
                            }),
                            fill: new Fill({
                                color: 'transparent'
                            })
                        }));
                    } else {
                        feature.setStyle(styleFunction(feature));
                    }
                });
            }
        }

        function triggerClickEventById(targetId) {
            if (!vectorSource || !selectInteraction) {
                console.error('Vector source or select interaction not available');
                return;
            }

            selectInteraction.getFeatures().clear();

            const featureNameEl = document.getElementById("feature-name");

            if (targetId === -1) {
                currentSelectedId = null;
                vectorSource.getFeatures().forEach(feature => {
                    feature.setStyle(styleFunction(feature));
                });

                if (featureNameEl) {
                    featureNameEl.textContent = "";
                }

                console.log('Cleared all feature selections');
                return;
            }

            const matchingFeatures = vectorSource.getFeatures().filter(f => {
                const data = f.get('data');
                return data && data.id === targetId;
            });

            if (matchingFeatures.length > 0) {
                currentSelectedId = targetId;
                
                vectorSource.getFeatures().forEach(feature => {
                    feature.setStyle(styleFunction(feature));
                });

                selectInteraction.getFeatures().push(matchingFeatures[0]);

                matchingFeatures.forEach(f => {
                    f.setStyle(new Style({
                        stroke: new Stroke({
                            color: 'red',
                            width: 3
                        }),
                        fill: new Fill({
                            color: 'transparent'
                        })
                    }));
                    f.changed();
                });
                
                vectorSource.changed();
                vectorLayer.changed();
                
                const featureData = matchingFeatures[0].get('data');
                if (featureData && featureData.name && featureNameEl) {
                    if (notAvailableTimeout) {
                        clearTimeout(notAvailableTimeout);
                        notAvailableTimeout = null;
                    }
                    featureNameEl.textContent = ` ${featureData.name}`;
                    featureNameEl.style.color = "";
                }
                console.log(`Highlighted ${matchingFeatures.length} features with ID: ${targetId}`);
            } else {
                currentSelectedId = null;
                
                if (selectInteraction) {
                    selectInteraction.getFeatures().clear();
                }
                
                vectorSource.getFeatures().forEach(feature => {
                    feature.setStyle(styleFunction(feature));
                });
                
                if (featureNameEl) {
                    if (notAvailableTimeout) {
                        clearTimeout(notAvailableTimeout);
                    }
                    
                    featureNameEl.textContent = "Region not available in this section";
                    featureNameEl.style.color = "#888";
                    
                    notAvailableTimeout = setTimeout(() => {
                        featureNameEl.textContent = "";
                        featureNameEl.style.color = "";
                        notAvailableTimeout = null;
                    }, 2000);
                }
                console.log(`No features found with ID: ${targetId}`);
            }
        }

        // Initialize Atlas Viewer
        function initializeAtlasViewer() {
            getGeoJSON(GEOJSON_URL).then(geojsonData => {
                const geojsonObject = geojsonData;

                vectorLayer = new VectorLayer({
                    transition: 0,
                    source: new VectorSource({
                        format: new GeoJSON(),
                        wrapX: false,
                    }),
                    style: styleFunction,
                });

                const zoomifySource = new Zoomify({
                    url: IMAGE_URL,
                    size: [72754, 86284], // This should be dynamic based on metadata
                    crossOrigin: "anonymous",
                    tierSizeCalculation: 'truncated',
                    imageSmoothing: false,
                    tileSize: 2048
                });

                const imagery = new TileLayer({
                    source: zoomifySource
                });

                const extent = zoomifySource.getTileGrid().getExtent();

                map = new Map({
                    layers: [imagery, vectorLayer],
                    target: 'map',
                    view: new View({
                        zoom: 10,
                        minZoom: 8,
                        maxZoom: 19,
                        rotation: (90 * Math.PI / 180), // This should be dynamic
                        extent: extent
                    }),
                    controls: ol.control.defaults({
                        zoom: false,
                        rotate: false,
                        attribution: false
                    })
                });

                window.map = map; // Make map globally accessible

                map.getView().fit(imagery.getSource().getTileGrid().getExtent());
                var centerMap = map.getView().getCenter();
                vectorSource = vectorLayer.getSource();

                var features = vectorSource.getFormat().readFeatures(geojsonObject);
                features.forEach(element => {
                    var elementRotate = element.getGeometry();
                    var xy = centerMap;
                    elementRotate = elementRotate.rotate(((90) * Math.PI / 180), xy);
                });
                vectorSource.addFeatures(features);
                vectorSource.getFeatures().forEach(element => {
                    element.setStyle(styleFunction(element));
                });

                selectInteraction = new Select({
                    condition: ol.events.condition.singleClick,
                    style: null,
                });

                map.addInteraction(selectInteraction);

                selectInteraction.on('select', async function (e) {
                    vectorSource.getFeatures().forEach(feature => {
                        feature.setStyle(styleFunction(feature));
                    });

                    const selected = e.selected;
                    const featureNameEl = document.getElementById("feature-name");

                    if (selected.length > 0) {
                        const clickedFeature = selected[0].getProperties();
                        const clickedId = clickedFeature.data.id;
                        const clickedName = clickedFeature.data.name;
                        
                        currentSelectedId = clickedId;

                        const matchingFeatures = vectorSource.getFeatures().filter(f => {
                            const data = f.get('data');
                            return data && data.id === clickedId;
                        });

                        matchingFeatures.forEach(f => {
                            f.setStyle(new Style({
                                stroke: new Stroke({
                                    color: 'red',
                                    width: 3
                                }),
                                fill: new Fill({
                                    color: 'transparent'
                                })
                            }));
                        });

                        if (notAvailableTimeout) {
                            clearTimeout(notAvailableTimeout);
                            notAvailableTimeout = null;
                        }

                        featureNameEl.textContent = ` ${clickedName}`;
                        featureNameEl.style.color = "";

                        const payload = {
                            id: session_id,
                            tool_name: 'atlas_viewer',
                            params: {
                                id: clickedId,
                                name: clickedName,
                                biosample: currentBiosample,
                                section: currentSection
                            }
                        };
                        window.parent.postMessage(payload, '*');

                    } else {
                        currentSelectedId = null;
                        
                        if (notAvailableTimeout) {
                            clearTimeout(notAvailableTimeout);
                            notAvailableTimeout = null;
                        }
                        
                        featureNameEl.textContent = "";
                        featureNameEl.style.color = "";

                        const payload = {
                            id: session_id,
                            tool_name: 'atlas_viewer',
                            params: {
                                id: -1,
                                name: null,
                                biosample: currentBiosample,
                                section: currentSection
                            }
                        };
                        window.parent.postMessage(payload, '*');
                    }
                });

                // Set up opacity slider
                let lastOpacity = opacityAtlas;
                let throttleTimeout = null;

                const opacitySlider = document.getElementById("opacity-slider");
                const opacityValueDisplay = document.getElementById("opacity-value");

                function throttledOpacityUpdate(newOpacity) {
                    if (newOpacity === lastOpacity) return;
                    lastOpacity = newOpacity;

                    opacityAtlas = newOpacity;
                    opacityValueDisplay.textContent = opacityAtlas;
                    updateLayerOpacity();
                }

                opacitySlider.addEventListener("input", function () {
                    const newOpacity = this.value.toString().padStart(2, '0');

                    if (throttleTimeout) clearTimeout(throttleTimeout);

                    throttleTimeout = setTimeout(() => {
                        throttledOpacityUpdate(newOpacity);
                    }, 10);
                });

                // Eye toggle functionality
                const eyeToggle = document.getElementById('eye-toggle');
                const eyeIcon = document.getElementById('eye-icon');

                eyeToggle.addEventListener('click', function() {
                    annotationsVisible = !annotationsVisible;
                    
                    if (annotationsVisible) {
                        vectorLayer.setVisible(true);
                        eyeIcon.innerHTML = `
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        `;
                        eyeIcon.classList.remove('hidden');
                        
                        if (currentSelectedId !== null) {
                            setTimeout(() => {
                                const matchingFeatures = vectorSource.getFeatures().filter(f => {
                                    const data = f.get('data');
                                    return data && data.id === currentSelectedId;
                                });
                                
                                if (matchingFeatures.length > 0) {
                                    selectInteraction.getFeatures().clear();
                                    
                                    vectorSource.getFeatures().forEach(feature => {
                                        feature.setStyle(styleFunction(feature));
                                        feature.changed();
                                    });
                                    
                                    selectInteraction.getFeatures().push(matchingFeatures[0]);
                                    
                                    matchingFeatures.forEach(f => {
                                        f.setStyle(new Style({
                                            stroke: new Stroke({
                                                color: 'red',
                                                width: 3
                                            }),
                                            fill: new Fill({
                                                color: 'transparent'
                                            })
                                        }));
                                        f.changed();
                                    });
                                    
                                    vectorSource.changed();
                                    vectorLayer.changed();
                                    map.render();
                                    
                                    const featureData = matchingFeatures[0].get('data');
                                    const featureNameEl = document.getElementById("feature-name");
                                    if (featureData && featureData.name && featureNameEl) {
                                        featureNameEl.textContent = ` ${featureData.name}`;
                                    }
                                }
                            }, 200);
                        }
                    } else {
                        vectorLayer.setVisible(false);
                        eyeIcon.innerHTML = `
                            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                            <line x1="1" y1="1" x2="23" y2="23"></line>
                        `;
                        eyeIcon.classList.add('hidden');
                    }
                });
            });
        }

        // ==================== Thumbnail Viewer Code ====================
        let imagesData = [];
        let startIndex = 0;
        let isAnimating = false;

        const gridWrapper = document.querySelector(".image-grid-wrapper");
        const grid1 = document.getElementById("image-grid-1");
        const grid2 = document.getElementById("image-grid-2");

        async function fetchImages() {
            try {
                const response = await fetch(THUMBNAIL_API_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                const selectedSeries = data.find(item => item.seriesType === currentSeriesType);
                imagesData = selectedSeries?.thumbnails ?? [];
                if (imagesData.length === 0) {
                    console.warn("No images found for the selected series.");
                    return;
                }
                
                let roiIndex = imagesData.findIndex(img => img.sectionNo == currentSection);

                if (roiIndex === -1) {
                    let closestDiff = Infinity;
                    let closestIndex = 0;
                    for (let i = 0; i < imagesData.length; i++) {
                        const diff = Math.abs(imagesData[i].sectionNo - currentSection);
                        if (diff < closestDiff) {
                            closestDiff = diff;
                            closestIndex = i;
                        }
                    }
                    roiIndex = closestIndex;
                }

                const columns = calculateColumns();
                const rows = Math.ceil((window.innerHeight - 100) / 100);
                const imagesPerPage = columns * rows;

                startIndex = roiIndex - Math.floor(imagesPerPage / 2);
                if (startIndex < 0) startIndex = 0;
                if (startIndex > imagesData.length - imagesPerPage) {
                    startIndex = Math.max(imagesData.length - imagesPerPage, 0);
                }

                renderImages(grid1, startIndex);
            } catch (error) {
                console.error("Error fetching images:", error);
            }
        }

        function calculateColumns() {
            const containerWidth = document.querySelector(".image-grid-container").clientWidth;
            return Math.floor(containerWidth / 90);
        }

        function calculateRows() {
            const thumbnailPanelHeight = thumbnailPanel.clientHeight - 100; // Account for header
            return Math.floor(thumbnailPanelHeight / 90);
        }

        function createImageElement(image, index) {
            const container = document.createElement("div");
            container.classList.add("image-container");
            container.setAttribute("data-section-no", image.sectionNo);

            const img = document.createElement("img");
            img.src = image.thumbnailUrl;
            
            img.onerror = function () {
                img.style.display = "none";
            };

            const label = document.createElement("span");
            label.classList.add("image-id");
            label.textContent = image.sectionNo;
            label.style.color = sectionColor(image.sectionstatus);

            if (image.is_annotation === 1) {
                const greenDot = document.createElement("div");
                greenDot.classList.add("green-dot");
                container.appendChild(greenDot);
            }

            container.appendChild(img);
            container.appendChild(label);

            // Highlight current section
            if (image.sectionNo == currentSection) {
                container.classList.add("selected");
            }

            return container;
        }

        function sectionColor(index) {
            switch(index) {
                case 0: return 'red';
                case 1: return 'orange';
                case 2: return '#f003fc';
                case 3: return 'blue';
                case 4: return '#2eb02e';
                default: return 'red';
            }
        }

        document.querySelector(".image-grid-container").addEventListener("click", async (event) => {
            const imageContainer = event.target.closest(".image-container");
            if (!imageContainer) return;

            const previouslySelected = document.querySelector(".image-container.selected");
            if (previouslySelected) {
                previouslySelected.classList.remove("selected");
            }

            imageContainer.classList.add("selected");

            const newSection = parseInt(imageContainer.getAttribute("data-section-no"));
            
            // Update current section and reload atlas viewer
            currentSection = newSection;
            document.getElementById('atlas-section').textContent = currentSection;
            
            // Clear current atlas data and reload with new section
            console.log(`Loading section ${currentSection}`);
            
            // Update the URLs with the new section
            const newGeojsonUrl = GEOJSON_URL.replace(/\/\d+\/[^/]+\.json$/, `/${currentSection}/222-NISL-${currentSection}-FlatTree::IIT:V1:SS-100:306:1000:1000.json`);
            const newImageUrl = IMAGE_URL.replace(/SE_\d+/, `SE_${currentSection}`);
            
            // Reinitialize atlas viewer with new section data
            if (window.map) {
                // Clear existing features
                if (vectorSource) {
                    vectorSource.clear();
                }
                
                // Load new GeoJSON data
                getGeoJSON(newGeojsonUrl).then(geojsonData => {
                    if (geojsonData && vectorSource) {
                        const features = vectorSource.getFormat().readFeatures(geojsonData);
                        const centerMap = map.getView().getCenter();
                        
                        features.forEach(element => {
                            const elementRotate = element.getGeometry();
                            elementRotate.rotate((90 * Math.PI / 180), centerMap);
                        });
                        
                        vectorSource.addFeatures(features);
                        vectorSource.getFeatures().forEach(element => {
                            element.setStyle(styleFunction(element));
                        });
                        
                        console.log(`Atlas updated with section ${currentSection}`);
                    }
                }).catch(error => {
                    console.error('Error updating atlas:', error);
                });
            }

            const payload = {
                id: session_id,
                tool_name: 'thumbnail_viewer',
                params: {
                    biosample: currentBiosample,
                    section: currentSection,
                },
            };

            window.parent.postMessage({ action_context: payload }, "*");
        });

        function renderImages(grid, index) {
            grid.innerHTML = "";

            const columns = calculateColumns();
            const rowHeight = 100;
            const rows = Math.ceil((window.innerHeight - 100) / rowHeight);
            const imagesPerPage = columns * rows;

            grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

            const sortedImages = [...imagesData].sort(
                (a, b) => parseInt(a.sectionNo) - parseInt(b.sectionNo)
            );
            const paginatedImages = sortedImages.slice(index, index + imagesPerPage);

            let columnWiseImages = Array.from({ length: rows }, () => Array(columns).fill(null));

            let imageIdx = 0;
            for (let col = 0; col < columns; col++) {
                for (let row = 0; row < rows; row++) {
                    if (imageIdx < paginatedImages.length) {
                        columnWiseImages[row][col] = paginatedImages[imageIdx];
                        imageIdx++;
                    }
                }
            }

            columnWiseImages.flat().forEach((image) => {
                if (image) {
                    grid.appendChild(createImageElement(image));
                }
            });
        }

        function scrollImages(direction) {
            if (isAnimating || !imagesData.length) return;
            isAnimating = true;

            const columns = calculateColumns();
            const rows = calculateRows();
            const imagesPerPage = columns * rows;
            let nextIndex = startIndex;

            if (direction === "next") {
                nextIndex += imagesPerPage;
            } else {
                nextIndex -= imagesPerPage;
            }

            nextIndex = Math.max(0, Math.min(nextIndex, imagesData.length - imagesPerPage));

            if (nextIndex === startIndex) {
                isAnimating = false;
                return;
            }

            // Use smooth scrolling animation
            const container = document.querySelector('.image-grid-container');
            const targetGrid = startIndex < nextIndex ? grid2 : grid1;
            
            // Render new images in the target grid
            renderImages(targetGrid, nextIndex);
            
            // Create smooth transition
            gridWrapper.style.transition = "transform 0.3s ease-in-out";
            gridWrapper.style.transform = `translateX(${startIndex < nextIndex ? "-50%" : "50%"})`;

            setTimeout(() => {
                gridWrapper.style.transition = "none";
                gridWrapper.style.transform = "translateX(0)";

                // Copy content to main grid
                if (startIndex < nextIndex) {
                    grid1.innerHTML = grid2.innerHTML;
                } else {
                    grid2.innerHTML = grid1.innerHTML;
                }

                startIndex = nextIndex;
                isAnimating = false;
            }, 300);
        }

        // Navigation buttons removed - using scroll wheel and keyboard only

        // Navigation button event listeners removed
        
        window.addEventListener("resize", () => {
            const columns = calculateColumns();
            const rows = Math.ceil((window.innerHeight - 100) / 100);
            const imagesPerPage = columns * rows;

            const sortedImages = [...imagesData].sort(
                (a, b) => parseInt(a.sectionNo) - parseInt(b.sectionNo)
            );

            const maxStart = Math.max(0, sortedImages.length - imagesPerPage);
            if (startIndex > maxStart) {
                startIndex = maxStart;
            }

            renderImages(grid1, startIndex);
            
            if (window.map) {
                window.map.updateSize();
            }
        });

        // Series selector change handler
        document.getElementById('series-select').addEventListener('change', function(e) {
            currentSeriesType = e.target.value;
            fetchImages();
        });

        // Add scroll wheel support for navigation
        document.querySelector('.image-grid-container').addEventListener('wheel', function(e) {
            if (isAnimating) return;
            
            const columns = calculateColumns();
            const rows = calculateRows();
            const imagesPerPage = columns * rows;
            const canGoNext = startIndex + imagesPerPage < imagesData.length;
            const canGoPrev = startIndex > 0;
            
            if (e.deltaY > 0) {
                // Scroll down - next page
                if (canGoNext) {
                    e.preventDefault();
                    scrollImages('next');
                }
            } else {
                // Scroll up - previous page
                if (canGoPrev) {
                    e.preventDefault();
                    scrollImages('prev');
                }
            }
        });

        // Add keyboard support
        document.addEventListener('keydown', function(e) {
            // Only handle keys when focus is on thumbnail area or no input is focused
            const focusedElement = document.activeElement;
            const isInputFocused = focusedElement.tagName === 'INPUT' || 
                                 focusedElement.tagName === 'TEXTAREA' || 
                                 focusedElement.contentEditable === 'true';
            
            if (!isInputFocused && !isAnimating) {
                const columns = calculateColumns();
                const rows = calculateRows();
                const imagesPerPage = columns * rows;
                const canGoNext = startIndex + imagesPerPage < imagesData.length;
                const canGoPrev = startIndex > 0;
                
                if (e.key === 'ArrowLeft' && canGoPrev) {
                    e.preventDefault();
                    scrollImages('prev');
                } else if (e.key === 'ArrowRight' && canGoNext) {
                    e.preventDefault();
                    scrollImages('next');
                }
            }
        });

        // ==================== Message Handlers ====================
        window.addEventListener('message', (event) => {
            console.log('Message received:', event.data);

            if (event.data.action === 'sayHi') {
                alert('Got this from parent: ' + event.data.data);
            }

            if (event.data.action === 'highlight' && event.data.region) {
                const { id } = event.data.region;
                console.log(`Triggering click event for region ID: ${id}`);
                triggerClickEventById(id);
            }

            if (event.data.id && event.data.name && event.data.type == "HighlightRegion" && typeof event.data.id === 'number') {
                console.log(`Triggering click event for region: ${event.data.name} (ID: ${event.data.id})`);
                triggerClickEventById(event.data.id);
            }

            // Handle updates from parent
            if (event.data.action === 'updateViewer' && event.data.params) {
                const { biosample, section, seriesType } = event.data.params;
                if (biosample) {
                    currentBiosample = biosample;
                    document.getElementById('thumbnail-biosample').textContent = biosample;
                    document.getElementById('atlas-biosample').textContent = biosample;
                }
                if (section) {
                    currentSection = section;
                    document.getElementById('atlas-section').textContent = section;
                }
                if (seriesType) {
                    currentSeriesType = seriesType;
                    document.getElementById('series-select').value = seriesType;
                }
                // Reinitialize viewers with new data
                fetchImages();
                initializeAtlasViewer();
            }
        });

        // ==================== Initialize ====================
        // Initialize both viewers when page loads
        window.addEventListener('load', function() {
            initializeAtlasViewer();
            fetchImages();
            
            // Initialize theme
            initializeTheme();
            
            // Clear chat history on page refresh
            clearChatHistoryOnRefresh();
        });
        
        // ==================== Chat History Clear on Refresh ====================
        function clearChatHistoryOnRefresh() {
            // Clear chat history on page refresh
            try {
                fetch('/api/chat-history', {
                    method: 'DELETE'
                }).then(response => {
                    if (response.ok) {
                        console.log('Chat history cleared on page refresh');
                    }
                }).catch(error => {
                    console.error('Error clearing chat history on refresh:', error);
                });
            } catch (error) {
                console.error('Error clearing chat history on refresh:', error);
            }
            
            // Also clear local UI state
            if (chatMessages) {
                chatMessages.innerHTML = '';
            }
            currentBrainRegion = null;
            if (currentRegionSpan) {
                currentRegionSpan.textContent = '';
            }
            if (askBtn) {
                askBtn.disabled = true;
            }
        }
        
        // ==================== Theme Toggle Functionality ====================
        function initializeTheme() {
            // Check for saved theme preference or default to dark theme
            const savedTheme = localStorage.getItem('theme') || 'dark';
            
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            }
        }
        
        // Theme toggle button click handler
        document.getElementById('themeToggle').addEventListener('click', function() {
            const isLight = document.body.classList.contains('light-theme');
            
            if (isLight) {
                // Switch to dark theme
                document.body.classList.remove('light-theme');
                localStorage.setItem('theme', 'dark');
            } else {
                // Switch to light theme
                document.body.classList.add('light-theme');
                localStorage.setItem('theme', 'light');
            }
            
            // Optional: Refresh map to apply theme changes properly
            if (window.map) {
                setTimeout(() => {
                    window.map.updateSize();
                }, 300);
            }
        });

        // ==================== Chatbot Functionality ====================
        let currentBrainRegion = null;
        let isWaitingForResponse = false;

        // DOM elements for chatbot
        const chatbotColumn = document.getElementById('chatbotColumn');
        const chatbotContainer = document.getElementById('chatbotContainer');
        const chatbotToggle = document.getElementById('chatbotToggle');
        const chatbotClose = document.getElementById('chatbotClose');
        const chatMessages = document.getElementById('chatMessages');
        const questionInput = document.getElementById('questionInput');
        const askBtn = document.getElementById('askBtn');
        const currentRegionSpan = document.getElementById('currentRegion');
        const historyBtn = document.getElementById('historyBtn');
        const clearBtn = document.getElementById('clearBtn');
        const historyModal = document.getElementById('historyModal');
        const closeHistoryModal = document.getElementById('closeHistoryModal');
        const closeHistoryBtn = document.getElementById('closeHistoryBtn');
        const historyList = document.getElementById('historyList');
        const historyStats = document.getElementById('historyStats');
        const downloadHistory = document.getElementById('downloadHistory');

        // Initialize chatbot event listeners
        chatbotToggle.addEventListener('click', () => {
            const isActive = chatbotColumn.classList.contains('active');
            if (isActive) {
                closeChatbot();
            } else {
                openChatbot();
            }
        });

        chatbotClose.addEventListener('click', () => {
            closeChatbot();
        });

        // Handle escape key to close chatbot
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && chatbotColumn.classList.contains('active')) {
                closeChatbot();
            }
        });

        function openChatbot() {
            mainContainer.classList.add('chatbot-active');
            chatbotColumn.classList.add('active');
            chatbotToggle.classList.add('hidden');
            
            // Trigger layout updates after animation completes
            setTimeout(() => {
                if (window.map) {
                    window.map.updateSize();
                }
                // Force reflow and recalculate thumbnail grid
                if (imagesData.length > 0) {
                    // Force browser to recalculate layout
                    document.querySelector('.thumbnail-panel').offsetHeight;
                    renderImages(grid1, startIndex);
                    updatePaginationButtons();
                }
            }, 450);
            
            // Focus on input if there's a selected region
            if (currentBrainRegion && questionInput) {
                setTimeout(() => questionInput.focus(), 400);
            }
        }

        function closeChatbot() {
            mainContainer.classList.remove('chatbot-active');
            chatbotColumn.classList.remove('active');
            chatbotToggle.classList.remove('hidden');
            
            // Trigger layout updates after animation completes
            setTimeout(() => {
                if (window.map) {
                    window.map.updateSize();
                }
                // Force reflow and recalculate thumbnail grid
                if (imagesData.length > 0) {
                    // Force browser to recalculate layout
                    document.querySelector('.thumbnail-panel').offsetHeight;
                    renderImages(grid1, startIndex);
                    updatePaginationButtons();
                }
            }, 450);
        }


        askBtn.addEventListener('click', handleAskQuestion);
        questionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !askBtn.disabled) {
                handleAskQuestion();
            }
        });

        // History button
        historyBtn.addEventListener('click', () => {
            showChatHistory();
        });

        // Clear history button
        clearBtn.addEventListener('click', () => {
            clearChatHistory();
        });

        // History modal close handlers
        closeHistoryModal.addEventListener('click', () => {
            historyModal.style.display = 'none';
        });
        
        closeHistoryBtn.addEventListener('click', () => {
            historyModal.style.display = 'none';
        });

        // Download history button
        downloadHistory.addEventListener('click', () => {
            downloadChatHistory();
        });

        // Close modal when clicking outside
        historyModal.addEventListener('click', (e) => {
            if (e.target === historyModal) {
                historyModal.style.display = 'none';
            }
        });

        // Enable/disable ask button based on input
        questionInput.addEventListener('input', () => {
            if (currentBrainRegion && questionInput.value.trim()) {
                askBtn.disabled = false;
            } else {
                askBtn.disabled = true;
            }
        });


        async function selectBrainRegion(regionName) {
            if (isWaitingForResponse) return;

            // Show chatbot
            openChatbot();
            
            // Update UI
            currentBrainRegion = regionName;
            currentRegionSpan.textContent = ` - ${regionName}`;
            askBtn.disabled = false;
            
            // Add user message
            addMessage(`Tell me about the ${regionName}`, 'user');
            
            // Show loading
            const loadingMsg = addMessage('', 'bot');
            loadingMsg.innerHTML = '<div class="loading"></div> Analyzing brain region...';
            
            // Get selected mode
            const mode = document.querySelector('input[name="mode"]:checked').value;
            
            isWaitingForResponse = true;
            
            try {
                // Use streaming endpoint
                const response = await fetch('/api/brain-region-stream', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            region: regionName,
                            mode: mode
                        })
                    });
                    
                    // Remove loading message
                    loadingMsg.remove();
                    
                    // Create a new message for streaming content
                    const streamMsg = addMessage('', 'bot');
                    let fullMessage = '';
                    
                    // Read the stream
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    if (data.chunk) {
                                        fullMessage += data.chunk;
                                        streamMsg.innerHTML = formatMessage(fullMessage);
                                        // Scroll to bottom
                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                    }
                                    if (data.complete && !data.success) {
                                        currentBrainRegion = null;
                                        currentRegionSpan.textContent = '';
                                        askBtn.disabled = true;
                                    }
                                } catch (e) {
                                    console.error('Error parsing stream data:', e);
                                }
                            }
                        }
                    }
            } catch (error) {
                loadingMsg.remove();
                addMessage(`Error: ${error.message}`, 'bot');
            } finally {
                isWaitingForResponse = false;
            }
        }

        async function handleAskQuestion() {
            const question = questionInput.value.trim();
            if (!question || !currentBrainRegion || isWaitingForResponse) return;
            
            // Add user message
            addMessage(question, 'user');
            
            // Clear input
            questionInput.value = '';
            
            // Show loading
            const loadingMsg = addMessage('', 'bot');
            loadingMsg.innerHTML = '<div class="loading"></div> Thinking...';
            
            // Get selected mode to determine if web search should be used
            const mode = document.querySelector('input[name="mode"]:checked').value;
            const useWeb = (mode === 'web'); // Automatically use web for 'Detailed (Web)' mode
            
            isWaitingForResponse = true;
            
            try {
                // Use streaming endpoint
                const response = await fetch('/api/ask-question-stream', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            question: question,
                            use_web: useWeb,
                            mode: mode
                        })
                    });
                    
                    // Remove loading message
                    loadingMsg.remove();
                    
                    // Create a new message for streaming content
                    const streamMsg = addMessage('', 'bot');
                    let fullMessage = '';
                    
                    // Read the stream
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    if (data.chunk) {
                                        fullMessage += data.chunk;
                                        streamMsg.innerHTML = formatMessage(fullMessage);
                                        // Scroll to bottom
                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                    }
                                    if (data.error) {
                                        streamMsg.innerHTML = formatMessage(`Error: ${data.error}`);
                                    }
                                } catch (e) {
                                    console.error('Error parsing stream data:', e);
                                }
                            }
                        }
                    }
                
            } catch (error) {
                loadingMsg.remove();
                addMessage(`Error: ${error.message}`, 'bot');
            } finally {
                isWaitingForResponse = false;
            }
        }

        function formatMessage(text) {
            // Convert markdown formatting to HTML
            let formattedText = text
                // Handle markdown headers (###, ##, #)
                .replace(/^### (.+)$/gm, '<h3>$1</h3>')
                .replace(/^## (.+)$/gm, '<h2>$1</h2>')
                .replace(/^# (.+)$/gm, '<h1>$1</h1>')
                // Handle numbered lists
                .replace(/^(\d+)\. (.+)$/gm, '<br>$1. $2')
                // PRIORITY 0: Exact problematic patterns first
                .replace(/^(Khan Academy Academic Search|Educational & Academic Sources|Medical & Clinical Databases|Alternative Search Results):/gim, '<strong>$1:</strong>')
                // PRIORITY 1: Specific source names (catch them before other patterns)
                .replace(/^(Wikipedia|PubMed|Google|Bing|Yahoo|DuckDuckGo|Yandex|Khan Academy|Educational|Medical|Clinical|Academic|Scientific|Alternative|Extended|Research|University|Nature|Science|NCBI|NIH|FDA|WHO)(\s+[A-Za-z\s&]*)?(?:\s*-\s*[^:]+)?:/gim, '<strong>$1$2:</strong>')
                // PRIORITY 2: Source - Topic format (like "Wikipedia - Cerebral cortex:")
                .replace(/^([A-Z][A-Za-z\s&]+)\s*-\s*([^:]+):/gm, '<strong>$1 - $2:</strong>')
                // PRIORITY 3: Any line with search/academic keywords
                .replace(/^([A-Z][^:\n]*?(?:Search|Results?|API|Database|Sources?|Engine|Web|Site|Portal|Research|Studies|Papers|Articles|Information|Data|Repository|Archive|Library|Index|Registry|Collection|Wikipedia|PubMed|Google|Bing|Yahoo|DuckDuckGo|Yandex|Searx|Startpage|Ecosia|Nature|Science|NCBI|NIH|FDA|WHO|Medical|Clinical|Journal|University|Academic|Study|Report|Article|Paper|Publication|Summary|Overview|Definition|Findings|Analysis|Review|Investigation|Khan|Academy|Educational|Extended|Alternative)[^:\n]*?(?:\s*\([^)]*\))?)\s*:/gim, '<strong>$1:</strong>')
                // PRIORITY 4: Multi-word headings with & (like "Educational & Academic Sources:")
                .replace(/^([A-Z][A-Za-z\s&-]{8,})\s*:/gm, '<strong>$1:</strong>')
                // PRIORITY 5: Catch ANY capitalized heading with parentheses
                .replace(/^([A-Z][A-Za-z\s&-]{3,}(?:\s*\([^)]*\)))\s*:/gim, '<strong>$1:</strong>')
                // PRIORITY 6: Simple capitalized headings (3+ words)
                .replace(/^([A-Z][A-Za-z]+(?:\s+[A-Z][A-Za-z]+){2,}(?:\s*\([^)]*\))?)\s*:/gim, '<strong>$1:</strong>')
                // PRIORITY 7: Any line that starts with capital and ends with colon
                .replace(/^([A-Z][A-Za-z\s&-]{5,})\s*:\s*(?=[A-Z‚Ä¢])/gm, '<strong>$1:</strong>')
                // PRIORITY 8: Common research terms
                .replace(/^(Sources?|References?|From|Based on|According to|Research shows|Studies indicate|Key findings|Summary|Overview|Definition|Clinical significance|Anatomy|Function|Location|Connections|Role in disease|Results|Findings|Conclusion|Abstract|Introduction|Methods|Discussion|Background|Objective|Purpose|Aim|Goal|Analysis|Review|Investigation|Extended|Alternative|Academic|Scientific|Educational|Additional|Recent|Current|Latest|Updated)(?:\s+[A-Za-z\s&]*)?:/gim, '<strong>$1:</strong>')
                // PRIORITY 9: Last resort - any reasonable heading format
                .replace(/^([A-Z][A-Za-z\s&]{2,})\s*:/gm, '<strong>$1:</strong>')
                // Handle bullet points: * item -> ‚Ä¢ item
                .replace(/^\* (.*$)/gm, '‚Ä¢ $1')
                // Handle bullet points: + item -> ‚Ä¢ item
                .replace(/^\+ (.*$)/gm, '‚Ä¢ $1')
                // Handle bullet points: - item -> ‚Ä¢ item
                .replace(/^- (.*$)/gm, '‚Ä¢ $1')
                // Bold text: **text** -> <strong>text</strong>
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // Underline: __text__ -> <u>text</u>
                .replace(/__(.*?)__/g, '<u>$1</u>')
                // Convert line breaks to <br>
                .replace(/\n/g, '<br>');
            
            return formattedText;
        }
        
        function addMessage(text, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            const messageP = document.createElement('p');
            messageP.innerHTML = formatMessage(text);
            
            messageDiv.appendChild(messageP);
            chatMessages.appendChild(messageDiv);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return messageP;
        }

        async function showChatHistory() {
            try {
                const response = await fetch('/api/chat-history');
                const data = await response.json();
                
                if (data.success) {
                    displayChatHistory(data.chat_history, data.current_region, data.current_mode);
                    historyModal.style.display = 'block';
                } else {
                    alert('Error loading chat history: ' + data.message);
                }
            } catch (error) {
                alert('Error loading chat history: ' + error.message);
            }
        }

        function displayChatHistory(history, currentRegion, currentMode) {
            // Update stats
            const totalMessages = history.length;
            const userQuestions = history.filter(msg => msg.type === 'user_query').length;
            const regions = [...new Set(history.filter(msg => msg.region).map(msg => msg.region))];
            
            historyStats.innerHTML = `
                <strong>Chat Statistics:</strong> 
                ${totalMessages} total messages, 
                ${userQuestions} questions asked, 
                ${regions.length} regions explored
                ${currentRegion ? `<br><strong>Current:</strong> ${currentRegion} (${currentMode || 'fast'} mode)` : ''}
            `;
            
            // Clear previous history
            historyList.innerHTML = '';
            
            if (history.length === 0) {
                historyList.innerHTML = '<div class="no-history">No chat history yet. Start exploring brain regions!</div>';
                return;
            }
            
            // Group messages by region for better organization
            const groupedHistory = {};
            history.forEach((msg, index) => {
                const region = msg.region || 'General';
                if (!groupedHistory[region]) {
                    groupedHistory[region] = [];
                }
                groupedHistory[region].push({...msg, index});
            });
            
            // Display grouped history
            Object.keys(groupedHistory).forEach(region => {
                const regionDiv = document.createElement('div');
                regionDiv.className = 'history-region-group';
                
                const regionHeader = document.createElement('h4');
                regionHeader.className = 'history-region-header';
                regionHeader.textContent = region;
                regionDiv.appendChild(regionHeader);
                
                groupedHistory[region].forEach(msg => {
                    const historyItem = document.createElement('div');
                    historyItem.className = `history-item ${msg.type}`;
                    
                    const timestamp = new Date(msg.timestamp).toLocaleString();
                    const typeLabel = {
                        'user_query': '‚ùì Question',
                        'region_info': 'üß† Region Info', 
                        'assistant_response': 'ü§ñ Answer'
                    }[msg.type] || 'üí¨ Message';
                    
                    historyItem.innerHTML = `
                        <div class="history-item-header">
                            <span class="history-type">${typeLabel}</span>
                            <span class="history-timestamp">${timestamp}</span>
                        </div>
                        <div class="history-content">${msg.content}</div>
                    `;
                    
                    regionDiv.appendChild(historyItem);
                });
                
                historyList.appendChild(regionDiv);
            });
        }

        async function downloadChatHistory() {
            try {
                const response = await fetch('/api/chat-history');
                const data = await response.json();
                
                if (data.success) {
                    const historyText = formatHistoryForDownload(data.chat_history);
                    const blob = new Blob([historyText], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `brain-assistant-history-${new Date().toISOString().split('T')[0]}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    alert('Error downloading chat history: ' + data.message);
                }
            } catch (error) {
                alert('Error downloading chat history: ' + error.message);
            }
        }

        function formatHistoryForDownload(history) {
            let text = 'Brain Assistant Chat History\n';
            text += '================================\n';
            text += `Generated on: ${new Date().toLocaleString()}\n\n`;
            
            let currentRegion = '';
            
            history.forEach((msg, index) => {
                const timestamp = new Date(msg.timestamp).toLocaleString();
                
                // Add region header when it changes
                if (msg.region && msg.region !== currentRegion) {
                    currentRegion = msg.region;
                    text += `\n--- ${currentRegion.toUpperCase()} ---\n`;
                }
                
                const typeLabel = {
                    'user_query': 'USER',
                    'region_info': 'ASSISTANT (Region Info)',
                    'assistant_response': 'ASSISTANT'
                }[msg.type] || 'MESSAGE';
                
                text += `[${timestamp}] ${typeLabel}:\n${msg.content}\n\n`;
            });
            
            return text;
        }

        async function clearChatHistory() {
            if (!confirm('Are you sure you want to clear all chat history? This cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch('/api/chat-history', {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Clear the chat messages UI
                    chatMessages.innerHTML = '';
                    currentBrainRegion = null;
                    currentRegionSpan.textContent = '';
                    askBtn.disabled = true;
                    alert('Chat history cleared successfully!');
                    // Close history modal if open
                    historyModal.style.display = 'none';
                } else {
                    alert('Error clearing chat history: ' + data.message);
                }
            } catch (error) {
                alert('Error clearing chat history: ' + error.message);
            }
        }

        // Integration with atlas viewer - when a region is clicked
        window.addEventListener('message', (event) => {
            if (event.data.tool_name === 'atlas_viewer' && event.data.params) {
                const { name, id } = event.data.params;
                if (name && id !== -1) {
                    // Auto-select the brain region in chatbot
                    selectBrainRegion(name);
                }
            }
        });

    </script>
</body>

</html>
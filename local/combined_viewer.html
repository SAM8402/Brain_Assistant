<!doctype html>
<html lang="en" style="height:100%;">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v5.3.0/css/ol.css" type="text/css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        /* Main container with 2 rows */
        .main-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 16px);
            width: calc(100vw - 16px);
            max-width: 1920px;
            background: #ffffff;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            border-radius: 16px;
            margin: 8px auto;
            overflow: hidden;
            position: relative;
        }
        
        @media (max-width: 768px) {
            .main-container {
                margin: 4px;
                border-radius: 8px;
                height: calc(100vh - 8px);
                width: calc(100vw - 8px);
            }
        }

        /* Top row for atlas viewer */
        .atlas-panel {
            height: 50%;
            width: 100%;
            position: relative;
            border-bottom: 1px solid #e5e7eb;
            background: #ffffff;
            border-radius: 16px 16px 0 0;
        }

        /* Bottom row for thumbnail viewer */
        .thumbnail-panel {
            height: 50%;
            width: 100%;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            display: flex;
            flex-direction: column;
            border-radius: 0 0 16px 16px;
        }

        /* Resize handle between panels */
        .resize-handle {
            height: 6px;
            background: linear-gradient(90deg, #6366f1, #8b5cf6);
            cursor: row-resize;
            position: relative;
            z-index: 1000;
            transition: all 0.2s ease;
        }

        .resize-handle:hover {
            height: 8px;
            background: linear-gradient(90deg, #4f46e5, #7c3aed);
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 3px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 2px;
        }

        /* Common header style */
        .header {
            margin: 0;
            padding: 16px 20px;
            color: #1f2937;
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border-bottom: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .header p {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header p::before {
            content: 'üß†';
            font-size: 16px;
        }

        .atlas-panel .header p::before {
            content: 'üó∫Ô∏è';
        }

        /* Atlas viewer specific styles */
        .name-container {
            display: flex;
            width: 100%;
            height: 0;
            position: absolute;
            top: 40px;
            z-index: 10;
        }

        .feature-name {
            font-size: 18px;
            font-weight: 600;
            padding: 12px 20px;
            z-index: 3;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            margin-left: 15px;
            color: #1f2937;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .map {
            height: calc(100% - 40px);
            width: 100%;
            position: relative;
            top: 40px;
        }

        /* Control panel container */
        .control-panel {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
        }
        
        @media (max-width: 768px) {
            .control-panel {
                left: 8px;
                gap: 8px;
            }
            
            .slider-container {
                width: 20px;
                height: 120px;
            }
            
            .eye-toggle-container {
                width: 20px;
                height: 20px;
            }
        }

        /* Opacity slider styles */
        .slider-container {
            height: 140px;
            width: 24px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .slider-container:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateX(-2px);
        }

        #opacity-slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;
            width: 3px;
            height: 90px;
            padding: 0;
            margin: 0;
        }

        /* Slider thumb styles */
        #opacity-slider::-webkit-slider-thumb {
            transform: scale(0.6);
            cursor: pointer;
        }

        #opacity-slider::-moz-range-thumb {
            transform: scale(0.6);
            cursor: pointer;
        }

        #opacity-slider::-ms-thumb {
            transform: scale(0.6);
            cursor: pointer;
        }

        .opacity-value {
            font-size: 10px;
            font-weight: 600;
            margin-top: 6px;
            color: #6366f1;
            background: rgba(99, 102, 241, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Eye toggle button styles */
        .eye-toggle-container {
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .eye-toggle-container:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateX(-2px) scale(1.05);
        }

        .eye-toggle-container:active {
            transform: translateX(-2px) scale(0.95);
        }

        .eye-icon {
            width: 14px;
            height: 14px;
            transition: all 0.3s ease;
            color: #6366f1;
        }

        .eye-icon.hidden {
            opacity: 0.5;
            color: #ef4444;
        }

        /* Thumbnail viewer specific styles */
        .thumbnail-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 10px;
            position: relative;
            flex: 1;
        }

        .image-grid-container {
            width: 100%;
            height: 100%;
            border: none;
            overflow: hidden;
        }

        .image-grid {
            display: grid;
            gap: 5px;
            width: 100%;
            height: 100%;
            padding: 10px;
            box-sizing: border-box;
        }

        .image-grid-wrapper {
            display: flex;
            width: 200%;
            transition: transform 0.5s ease-in-out;
        }

        .image-container {
            position: relative;
            border: 2px solid #e5e7eb;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 90px;
            height: 90px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .green-dot {
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-radius: 50%;
            position: absolute;
            top: 6px;
            right: 6px;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .image-container:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            border-color: #6366f1;
        }

        .image-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .image-id {
            position: absolute;
            bottom: 6px;
            left: 6px;
            color: #ffffff;
            background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .nav-buttons {
            padding: 12px 16px;
            font-size: 18px;
            cursor: pointer;
            border: none;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 2;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
            transition: all 0.3s ease;
        }

        .nav-buttons:hover:not(:disabled) {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
        }

        .nav-buttons:active:not(:disabled) {
            transform: translateY(-50%) scale(0.95);
        }

        #prev {
            left: 5px;
        }

        #next {
            right: 5px;
        }

        .nav-buttons:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #9ca3af;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .selected {
            border: 3px solid #6366f1 !important;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2), 0 8px 25px rgba(99, 102, 241, 0.3) !important;
            transform: translateY(-2px) !important;
        }

        /* Series selector */
        .series-selector {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 16px;
        }

        .series-selector select {
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 500;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: #ffffff;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .series-selector select:hover {
            border-color: #6366f1;
        }

        .series-selector select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v5.3.0/build/ol.js"></script>
    <title>Combined Brain Viewer</title>
</head>

<body style="height:100%;">
    <div class="main-container">
        <!-- Top row: Atlas viewer panel -->
        <div class="atlas-panel">
            <div class="header">
                <p>Atlas Viewer - Biosample: <span id="atlas-biosample">222</span> Section: <span id="atlas-section">1000</span></p>
            </div>
            <div class="name-container">
                <span class="feature-name" id="feature-name"></span>
            </div>
            <div id="map" class="map"></div>

            <!-- Control panel -->
            <div class="control-panel">
                <!-- Opacity slider control -->
                <div class="slider-container">
                    <input type="range" min="0" max="99" value="50" class="slider" id="opacity-slider" orient="vertical">
                    <div class="opacity-value" id="opacity-value">50</div>
                </div>

                <!-- Eye toggle button -->
                <div class="eye-toggle-container" id="eye-toggle" title="Toggle annotations visibility">
                    <svg class="eye-icon" id="eye-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </div>
            </div>
        </div>

        <!-- Resize handle -->
        <div class="resize-handle"></div>

        <!-- Bottom row: Thumbnail viewer panel -->
        <div class="thumbnail-panel" id="thumbnail-panel">
            <div class="header">
                <p>Thumbnail Viewer - Biosample: <span id="thumbnail-biosample">222</span> 
                   <span class="series-selector">
                       Series: <select id="series-select">
                           <option value="NISSL">NISSL</option>
                           <option value="HEOS">H&E</option>
                           <option value="BFI">Block Face Image</option>
                           <option value="MYEL">Myelin</option>
                       </select>
                   </span>
                </p>
            </div>
            <div class="thumbnail-content">
                <div class="container">
                    <button id="prev" class="nav-buttons" disabled>&#11164;</button>
                    <div class="image-grid-container">
                        <div class="image-grid-wrapper">
                            <div id="image-grid-1" class="image-grid"></div>
                            <div id="image-grid-2" class="image-grid"></div>
                        </div>
                    </div>
                    <button id="next" class="nav-buttons">&#11166;</button>
                </div>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        // ==================== Configuration ====================
        // These values would be dynamically set by the Flask app
        const THUMBNAIL_API_URL = `https://llm.humanbrain.in:1062/get/brain/thumbnails/100`;
        const GEOJSON_URL = `https://apollo2.humanbrain.in/iipsrv/ddn/storageIIT/humanbrain/analytics/222/appData/atlasEditor/189/NISL/1000/222-NISL-1000-FlatTree::IIT:V1:SS-100:306:1000:1000.json`;
        const IMAGE_URL = `https://apollo2.humanbrain.in/iipsrv/fcgi-bin/iipsrv.fcgi?FIF=/ddn/storageIIT/humanbrain/analytics/222/NISL/B_222_FB74-SL_334-ST_NISL-SE_1000_compressed.jp2&WID=1024&GAM=1.4&MINMAX=1:0,255&MINMAX=2:0,255&MINMAX=3:0,255&JTL={z},{tileIndex}`;
        
        // Initial configuration
        let currentBiosample = 222;
        let currentSection = 1000;
        let currentSeriesType = 'NISSL';
        const session_id = 'demo_session';
        const tool_name = 'combined_viewer';
        
        // ==================== Panel Resize Functionality ====================
        let isResizing = false;
        const resizeHandle = document.querySelector('.resize-handle');
        const atlasPanel = document.querySelector('.atlas-panel');
        const thumbnailPanel = document.querySelector('.thumbnail-panel');
        const mainContainer = document.querySelector('.main-container');
        
        resizeHandle.addEventListener('mousedown', function(e) {
            isResizing = true;
            document.body.style.cursor = 'row-resize';
            document.body.style.userSelect = 'none';
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = mainContainer.getBoundingClientRect();
            const newAtlasHeight = ((e.clientY - containerRect.top) / containerRect.height) * 100;
            
            if (newAtlasHeight >= 20 && newAtlasHeight <= 80) {
                atlasPanel.style.height = newAtlasHeight + '%';
                thumbnailPanel.style.height = (100 - newAtlasHeight) + '%';
                
                if (window.map) {
                    setTimeout(() => window.map.updateSize(), 100);
                }
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        // ==================== Atlas Viewer Code ====================
        const Feature = ol.Feature;
        const Map = ol.Map;
        const View = ol.View;
        const GeoJSON = ol.format.GeoJSON;
        const Circle = ol.geom.Circle;
        const Point = ol.geom.Point;
        const Icon = ol.style.Icon;
        const TileLayer = ol.layer.Tile;
        const VectorLayer = ol.layer.Vector;
        const OSM = ol.source.OSM;
        const VectorSource = ol.source.Vector;
        const CircleStyle = ol.style.Circle;
        const Fill = ol.style.Fill;
        const Stroke = ol.style.Stroke;
        const Style = ol.style.Style;
        const Zoomify = ol.source.Zoomify;
        const Select = ol.interaction.Select;

        // Atlas viewer variables
        let opacityAtlas = '50';
        let vectorSource;
        let selectInteraction;
        let annotationsVisible = true;
        let currentSelectedId = null;
        let vectorLayer;
        let map;
        let notAvailableTimeout = null;

        async function getGeoJSON(url) {
            try {
                const response = await fetch(url);
                return await response.json();
            } catch (error) {
                console.error('Error fetching GeoJSON:', error);
                return null;
            }
        }

        function styleFunction(feature) {
            if (typeof (opacityAtlas) == "number") {
                opacityAtlas = '50'
            }
            var data = feature.get('data')
            var clr = '#FF000070'

            if (data !== undefined && data.color_hex_triplet != undefined) {
                clr = data.color_hex_triplet;
                if (!data.color_hex_triplet.startsWith('#')) {
                    clr = '#' + clr
                }
            }

            if (clr.length == 7) {
                var atlasClr = clr;
                clr = clr + opacityAtlas;
            }

            var st = [
                new Style({
                    zIndex: -1,
                    stroke: new Stroke({
                        color: atlasClr,
                        width: 2.5,
                    }),
                    fill: new Fill({
                        color: clr
                    }),
                }),
            ];

            var geometry = feature.getGeometry();
            if (geometry.getType() === 'LineString') {
                var coordinates = geometry.getCoordinates();
                if (coordinates.length >= 2) {
                    var start = coordinates[coordinates.length - 2];
                    var end = coordinates[coordinates.length - 1];

                    var dx = end[0] - start[0];
                    var dy = end[1] - start[1];
                    var rotation = Math.atan2(dy, dx);

                    st.push(new Style({
                        stroke: new Stroke({
                            color: '#000000',
                            width: 3,
                        })
                    }));

                    st.push(new Style({
                        geometry: new Point(end),
                        image: new Icon({
                            src: 'https://apollo2.humanbrain.in/viewer/assets/images/colorsvg/right_arrow.svg',
                            anchor: [0.75, 0.5],
                            rotateWithView: true,
                            rotation: -rotation,
                        })
                    }));
                }
            }

            st.push(new Style({
                zIndex: -1,
                image: new CircleStyle({
                    radius: 5.9,
                    stroke: new Stroke({
                        color: atlasClr,
                        width: 1,
                    }),
                    fill: new Fill({
                        color: clr,
                    }),
                }),
                geometry: function (feature) {
                    var coordinates = feature.getGeometry().getCoordinates();
                    return new Point(coordinates);
                },
            }));

            return st;
        }

        function updateLayerOpacity() {
            if (vectorSource) {
                vectorSource.getFeatures().forEach(feature => {
                    const data = feature.get('data');
                    const isHighlighted = currentSelectedId !== null && data && data.id === currentSelectedId;
                    
                    if (isHighlighted) {
                        feature.setStyle(new Style({
                            stroke: new Stroke({
                                color: 'red',
                                width: 3
                            }),
                            fill: new Fill({
                                color: 'transparent'
                            })
                        }));
                    } else {
                        feature.setStyle(styleFunction(feature));
                    }
                });
            }
        }

        function triggerClickEventById(targetId) {
            if (!vectorSource || !selectInteraction) {
                console.error('Vector source or select interaction not available');
                return;
            }

            selectInteraction.getFeatures().clear();

            const featureNameEl = document.getElementById("feature-name");

            if (targetId === -1) {
                currentSelectedId = null;
                vectorSource.getFeatures().forEach(feature => {
                    feature.setStyle(styleFunction(feature));
                });

                if (featureNameEl) {
                    featureNameEl.textContent = "";
                }

                console.log('Cleared all feature selections');
                return;
            }

            const matchingFeatures = vectorSource.getFeatures().filter(f => {
                const data = f.get('data');
                return data && data.id === targetId;
            });

            if (matchingFeatures.length > 0) {
                currentSelectedId = targetId;
                
                vectorSource.getFeatures().forEach(feature => {
                    feature.setStyle(styleFunction(feature));
                });

                selectInteraction.getFeatures().push(matchingFeatures[0]);

                matchingFeatures.forEach(f => {
                    f.setStyle(new Style({
                        stroke: new Stroke({
                            color: 'red',
                            width: 3
                        }),
                        fill: new Fill({
                            color: 'transparent'
                        })
                    }));
                    f.changed();
                });
                
                vectorSource.changed();
                vectorLayer.changed();
                
                const featureData = matchingFeatures[0].get('data');
                if (featureData && featureData.name && featureNameEl) {
                    if (notAvailableTimeout) {
                        clearTimeout(notAvailableTimeout);
                        notAvailableTimeout = null;
                    }
                    featureNameEl.textContent = ` ${featureData.name}`;
                    featureNameEl.style.color = "";
                }
                console.log(`Highlighted ${matchingFeatures.length} features with ID: ${targetId}`);
            } else {
                currentSelectedId = null;
                
                if (selectInteraction) {
                    selectInteraction.getFeatures().clear();
                }
                
                vectorSource.getFeatures().forEach(feature => {
                    feature.setStyle(styleFunction(feature));
                });
                
                if (featureNameEl) {
                    if (notAvailableTimeout) {
                        clearTimeout(notAvailableTimeout);
                    }
                    
                    featureNameEl.textContent = "Region not available in this section";
                    featureNameEl.style.color = "#888";
                    
                    notAvailableTimeout = setTimeout(() => {
                        featureNameEl.textContent = "";
                        featureNameEl.style.color = "";
                        notAvailableTimeout = null;
                    }, 2000);
                }
                console.log(`No features found with ID: ${targetId}`);
            }
        }

        // Initialize Atlas Viewer
        function initializeAtlasViewer() {
            getGeoJSON(GEOJSON_URL).then(geojsonData => {
                const geojsonObject = geojsonData;

                vectorLayer = new VectorLayer({
                    transition: 0,
                    source: new VectorSource({
                        format: new GeoJSON(),
                        wrapX: false,
                    }),
                    style: styleFunction,
                });

                const zoomifySource = new Zoomify({
                    url: IMAGE_URL,
                    size: [72754, 86284], // This should be dynamic based on metadata
                    crossOrigin: "anonymous",
                    tierSizeCalculation: 'truncated',
                    imageSmoothing: false,
                    tileSize: 2048
                });

                const imagery = new TileLayer({
                    source: zoomifySource
                });

                const extent = zoomifySource.getTileGrid().getExtent();

                map = new Map({
                    layers: [imagery, vectorLayer],
                    target: 'map',
                    view: new View({
                        zoom: 10,
                        minZoom: 8,
                        maxZoom: 19,
                        rotation: (90 * Math.PI / 180), // This should be dynamic
                        extent: extent
                    }),
                    controls: ol.control.defaults({
                        rotate: false
                    })
                });

                window.map = map; // Make map globally accessible

                map.getView().fit(imagery.getSource().getTileGrid().getExtent());
                var centerMap = map.getView().getCenter();
                vectorSource = vectorLayer.getSource();

                var features = vectorSource.getFormat().readFeatures(geojsonObject);
                features.forEach(element => {
                    var elementRotate = element.getGeometry();
                    var xy = centerMap;
                    elementRotate = elementRotate.rotate(((90) * Math.PI / 180), xy);
                });
                vectorSource.addFeatures(features);
                vectorSource.getFeatures().forEach(element => {
                    element.setStyle(styleFunction(element));
                });

                selectInteraction = new Select({
                    condition: ol.events.condition.singleClick,
                    style: null,
                });

                map.addInteraction(selectInteraction);

                selectInteraction.on('select', async function (e) {
                    vectorSource.getFeatures().forEach(feature => {
                        feature.setStyle(styleFunction(feature));
                    });

                    const selected = e.selected;
                    const featureNameEl = document.getElementById("feature-name");

                    if (selected.length > 0) {
                        const clickedFeature = selected[0].getProperties();
                        const clickedId = clickedFeature.data.id;
                        const clickedName = clickedFeature.data.name;
                        
                        currentSelectedId = clickedId;

                        const matchingFeatures = vectorSource.getFeatures().filter(f => {
                            const data = f.get('data');
                            return data && data.id === clickedId;
                        });

                        matchingFeatures.forEach(f => {
                            f.setStyle(new Style({
                                stroke: new Stroke({
                                    color: 'red',
                                    width: 3
                                }),
                                fill: new Fill({
                                    color: 'transparent'
                                })
                            }));
                        });

                        if (notAvailableTimeout) {
                            clearTimeout(notAvailableTimeout);
                            notAvailableTimeout = null;
                        }

                        featureNameEl.textContent = ` ${clickedName}`;
                        featureNameEl.style.color = "";

                        const payload = {
                            id: session_id,
                            tool_name: 'atlas_viewer',
                            params: {
                                id: clickedId,
                                name: clickedName,
                                biosample: currentBiosample,
                                section: currentSection
                            }
                        };
                        window.parent.postMessage(payload, '*');

                    } else {
                        currentSelectedId = null;
                        
                        if (notAvailableTimeout) {
                            clearTimeout(notAvailableTimeout);
                            notAvailableTimeout = null;
                        }
                        
                        featureNameEl.textContent = "";
                        featureNameEl.style.color = "";

                        const payload = {
                            id: session_id,
                            tool_name: 'atlas_viewer',
                            params: {
                                id: -1,
                                name: null,
                                biosample: currentBiosample,
                                section: currentSection
                            }
                        };
                        window.parent.postMessage(payload, '*');
                    }
                });

                // Set up opacity slider
                let lastOpacity = opacityAtlas;
                let throttleTimeout = null;

                const opacitySlider = document.getElementById("opacity-slider");
                const opacityValueDisplay = document.getElementById("opacity-value");

                function throttledOpacityUpdate(newOpacity) {
                    if (newOpacity === lastOpacity) return;
                    lastOpacity = newOpacity;

                    opacityAtlas = newOpacity;
                    opacityValueDisplay.textContent = opacityAtlas;
                    updateLayerOpacity();
                }

                opacitySlider.addEventListener("input", function () {
                    const newOpacity = this.value.toString().padStart(2, '0');

                    if (throttleTimeout) clearTimeout(throttleTimeout);

                    throttleTimeout = setTimeout(() => {
                        throttledOpacityUpdate(newOpacity);
                    }, 10);
                });

                // Eye toggle functionality
                const eyeToggle = document.getElementById('eye-toggle');
                const eyeIcon = document.getElementById('eye-icon');

                eyeToggle.addEventListener('click', function() {
                    annotationsVisible = !annotationsVisible;
                    
                    if (annotationsVisible) {
                        vectorLayer.setVisible(true);
                        eyeIcon.innerHTML = `
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        `;
                        eyeIcon.classList.remove('hidden');
                        
                        if (currentSelectedId !== null) {
                            setTimeout(() => {
                                const matchingFeatures = vectorSource.getFeatures().filter(f => {
                                    const data = f.get('data');
                                    return data && data.id === currentSelectedId;
                                });
                                
                                if (matchingFeatures.length > 0) {
                                    selectInteraction.getFeatures().clear();
                                    
                                    vectorSource.getFeatures().forEach(feature => {
                                        feature.setStyle(styleFunction(feature));
                                        feature.changed();
                                    });
                                    
                                    selectInteraction.getFeatures().push(matchingFeatures[0]);
                                    
                                    matchingFeatures.forEach(f => {
                                        f.setStyle(new Style({
                                            stroke: new Stroke({
                                                color: 'red',
                                                width: 3
                                            }),
                                            fill: new Fill({
                                                color: 'transparent'
                                            })
                                        }));
                                        f.changed();
                                    });
                                    
                                    vectorSource.changed();
                                    vectorLayer.changed();
                                    map.render();
                                    
                                    const featureData = matchingFeatures[0].get('data');
                                    const featureNameEl = document.getElementById("feature-name");
                                    if (featureData && featureData.name && featureNameEl) {
                                        featureNameEl.textContent = ` ${featureData.name}`;
                                    }
                                }
                            }, 200);
                        }
                    } else {
                        vectorLayer.setVisible(false);
                        eyeIcon.innerHTML = `
                            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                            <line x1="1" y1="1" x2="23" y2="23"></line>
                        `;
                        eyeIcon.classList.add('hidden');
                    }
                });
            });
        }

        // ==================== Thumbnail Viewer Code ====================
        let imagesData = [];
        let startIndex = 0;
        let isAnimating = false;

        const gridWrapper = document.querySelector(".image-grid-wrapper");
        const grid1 = document.getElementById("image-grid-1");
        const grid2 = document.getElementById("image-grid-2");
        const prevButton = document.getElementById("prev");
        const nextButton = document.getElementById("next");

        async function fetchImages() {
            try {
                const response = await fetch(THUMBNAIL_API_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                const selectedSeries = data.find(item => item.seriesType === currentSeriesType);
                imagesData = selectedSeries?.thumbnails ?? [];
                if (imagesData.length === 0) {
                    console.warn("No images found for the selected series.");
                    return;
                }
                
                let roiIndex = imagesData.findIndex(img => img.sectionNo == currentSection);

                if (roiIndex === -1) {
                    let closestDiff = Infinity;
                    let closestIndex = 0;
                    for (let i = 0; i < imagesData.length; i++) {
                        const diff = Math.abs(imagesData[i].sectionNo - currentSection);
                        if (diff < closestDiff) {
                            closestDiff = diff;
                            closestIndex = i;
                        }
                    }
                    roiIndex = closestIndex;
                }

                const columns = calculateColumns();
                const rows = Math.ceil((window.innerHeight - 100) / 100);
                const imagesPerPage = columns * rows;

                startIndex = roiIndex - Math.floor(imagesPerPage / 2);
                if (startIndex < 0) startIndex = 0;
                if (startIndex > imagesData.length - imagesPerPage) {
                    startIndex = Math.max(imagesData.length - imagesPerPage, 0);
                }

                renderImages(grid1, startIndex);
                updatePaginationButtons();
            } catch (error) {
                console.error("Error fetching images:", error);
            }
        }

        function calculateColumns() {
            const containerWidth = document.querySelector(".image-grid-container").clientWidth;
            return Math.floor(containerWidth / 90);
        }

        function calculateRows() {
            const thumbnailPanelHeight = thumbnailPanel.clientHeight - 100; // Account for header
            return Math.floor(thumbnailPanelHeight / 90);
        }

        function createImageElement(image, index) {
            const container = document.createElement("div");
            container.classList.add("image-container");
            container.setAttribute("data-section-no", image.sectionNo);

            const img = document.createElement("img");
            img.src = image.thumbnailUrl;
            
            img.onerror = function () {
                img.style.display = "none";
            };

            const label = document.createElement("span");
            label.classList.add("image-id");
            label.textContent = image.sectionNo;
            label.style.color = sectionColor(image.sectionstatus);

            if (image.is_annotation === 1) {
                const greenDot = document.createElement("div");
                greenDot.classList.add("green-dot");
                container.appendChild(greenDot);
            }

            container.appendChild(img);
            container.appendChild(label);

            // Highlight current section
            if (image.sectionNo == currentSection) {
                container.classList.add("selected");
            }

            return container;
        }

        function sectionColor(index) {
            switch(index) {
                case 0: return 'red';
                case 1: return 'orange';
                case 2: return '#f003fc';
                case 3: return 'blue';
                case 4: return '#2eb02e';
                default: return 'red';
            }
        }

        document.querySelector(".image-grid-container").addEventListener("click", async (event) => {
            const imageContainer = event.target.closest(".image-container");
            if (!imageContainer) return;

            const previouslySelected = document.querySelector(".image-container.selected");
            if (previouslySelected) {
                previouslySelected.classList.remove("selected");
            }

            imageContainer.classList.add("selected");

            const newSection = parseInt(imageContainer.getAttribute("data-section-no"));
            
            // Update current section and reload atlas viewer
            currentSection = newSection;
            document.getElementById('atlas-section').textContent = currentSection;
            
            // Clear current atlas data and reload with new section
            console.log(`Loading section ${currentSection}`);
            
            // Update the URLs with the new section
            const newGeojsonUrl = GEOJSON_URL.replace(/\/\d+\/[^/]+\.json$/, `/${currentSection}/222-NISL-${currentSection}-FlatTree::IIT:V1:SS-100:306:1000:1000.json`);
            const newImageUrl = IMAGE_URL.replace(/SE_\d+/, `SE_${currentSection}`);
            
            // Reinitialize atlas viewer with new section data
            if (window.map) {
                // Clear existing features
                if (vectorSource) {
                    vectorSource.clear();
                }
                
                // Load new GeoJSON data
                getGeoJSON(newGeojsonUrl).then(geojsonData => {
                    if (geojsonData && vectorSource) {
                        const features = vectorSource.getFormat().readFeatures(geojsonData);
                        const centerMap = map.getView().getCenter();
                        
                        features.forEach(element => {
                            const elementRotate = element.getGeometry();
                            elementRotate.rotate((90 * Math.PI / 180), centerMap);
                        });
                        
                        vectorSource.addFeatures(features);
                        vectorSource.getFeatures().forEach(element => {
                            element.setStyle(styleFunction(element));
                        });
                        
                        console.log(`Atlas updated with section ${currentSection}`);
                    }
                }).catch(error => {
                    console.error('Error updating atlas:', error);
                });
            }

            const payload = {
                id: session_id,
                tool_name: 'thumbnail_viewer',
                params: {
                    biosample: currentBiosample,
                    section: currentSection,
                },
            };

            window.parent.postMessage({ action_context: payload }, "*");
        });

        function renderImages(grid, index) {
            grid.innerHTML = "";

            const columns = calculateColumns();
            const rowHeight = 100;
            const rows = Math.ceil((window.innerHeight - 100) / rowHeight);
            const imagesPerPage = columns * rows;

            grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

            const sortedImages = [...imagesData].sort(
                (a, b) => parseInt(a.sectionNo) - parseInt(b.sectionNo)
            );
            const paginatedImages = sortedImages.slice(index, index + imagesPerPage);

            let columnWiseImages = Array.from({ length: rows }, () => Array(columns).fill(null));

            let imageIdx = 0;
            for (let col = 0; col < columns; col++) {
                for (let row = 0; row < rows; row++) {
                    if (imageIdx < paginatedImages.length) {
                        columnWiseImages[row][col] = paginatedImages[imageIdx];
                        imageIdx++;
                    }
                }
            }

            columnWiseImages.flat().forEach((image) => {
                if (image) {
                    grid.appendChild(createImageElement(image));
                }
            });
        }

        function scrollImages(direction) {
            if (isAnimating) return;
            isAnimating = true;

            const columns = calculateColumns();
            const rows = Math.ceil((window.innerHeight - 100) / 100);
            const imagesPerPage = columns * rows;
            let nextIndex = startIndex;

            if (direction === "next") {
                nextIndex += imagesPerPage;
            } else {
                nextIndex -= imagesPerPage;
            }

            nextIndex = Math.max(0, Math.min(nextIndex, imagesData.length - imagesPerPage));

            if (nextIndex === startIndex) {
                isAnimating = false;
                return;
            }

            const newGrid = startIndex < nextIndex ? grid2 : grid1;
            renderImages(newGrid, nextIndex);

            gridWrapper.style.transition = "transform 0.5s ease-in-out";
            gridWrapper.style.transform = `translateX(${startIndex < nextIndex ? "-100%" : "100%"})`;

            setTimeout(() => {
                gridWrapper.style.transition = "none";
                gridWrapper.style.transform = "translateX(0)";

                if (startIndex < nextIndex) {
                    grid1.innerHTML = grid2.innerHTML;
                } else {
                    grid2.innerHTML = grid1.innerHTML;
                }

                startIndex = nextIndex;
                isAnimating = false;
                updatePaginationButtons();
            }, 500);
        }

        function updatePaginationButtons() {
            const columns = calculateColumns();
            const rows = Math.ceil((window.innerHeight - 100) / 100);
            const imagesPerPage = columns * rows;

            prevButton.disabled = startIndex === 0;
            nextButton.disabled = startIndex + imagesPerPage >= imagesData.length;
        }

        prevButton.addEventListener("click", () => scrollImages("prev"));
        nextButton.addEventListener("click", () => scrollImages("next"));
        
        window.addEventListener("resize", () => {
            const columns = calculateColumns();
            const rows = Math.ceil((window.innerHeight - 100) / 100);
            const imagesPerPage = columns * rows;

            const sortedImages = [...imagesData].sort(
                (a, b) => parseInt(a.sectionNo) - parseInt(b.sectionNo)
            );

            const maxStart = Math.max(0, sortedImages.length - imagesPerPage);
            if (startIndex > maxStart) {
                startIndex = maxStart;
            }

            renderImages(grid1, startIndex);
            updatePaginationButtons();
            
            if (window.map) {
                window.map.updateSize();
            }
        });

        // Series selector change handler
        document.getElementById('series-select').addEventListener('change', function(e) {
            currentSeriesType = e.target.value;
            fetchImages();
        });

        // ==================== Message Handlers ====================
        window.addEventListener('message', (event) => {
            console.log('Message received:', event.data);

            if (event.data.action === 'sayHi') {
                alert('Got this from parent: ' + event.data.data);
            }

            if (event.data.action === 'highlight' && event.data.region) {
                const { id } = event.data.region;
                console.log(`Triggering click event for region ID: ${id}`);
                triggerClickEventById(id);
            }

            if (event.data.id && event.data.name && event.data.type == "HighlightRegion" && typeof event.data.id === 'number') {
                console.log(`Triggering click event for region: ${event.data.name} (ID: ${event.data.id})`);
                triggerClickEventById(event.data.id);
            }

            // Handle updates from parent
            if (event.data.action === 'updateViewer' && event.data.params) {
                const { biosample, section, seriesType } = event.data.params;
                if (biosample) {
                    currentBiosample = biosample;
                    document.getElementById('thumbnail-biosample').textContent = biosample;
                    document.getElementById('atlas-biosample').textContent = biosample;
                }
                if (section) {
                    currentSection = section;
                    document.getElementById('atlas-section').textContent = section;
                }
                if (seriesType) {
                    currentSeriesType = seriesType;
                    document.getElementById('series-select').value = seriesType;
                }
                // Reinitialize viewers with new data
                fetchImages();
                initializeAtlasViewer();
            }
        });

        // ==================== Initialize ====================
        // Initialize both viewers when page loads
        window.addEventListener('load', function() {
            initializeAtlasViewer();
            fetchImages();
        });

    </script>
</body>

</html>